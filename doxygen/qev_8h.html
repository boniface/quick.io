<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>QuickIO: lib/quick-event/src/qev.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QuickIO
   &#160;<span id="projectnumber">0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_b261912c97c901759a7740fd897ed997.html">quick-event</a></li><li class="navelem"><a class="el" href="dir_95ddc183e27dff4f6e8bfed7d062aafa.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">qev.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides all the qev_* functions that are needed for creating an event loop.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;arpa/inet.h&gt;</code><br/>
<code>#include &lt;errno.h&gt;</code><br/>
<code>#include &lt;glib.h&gt;</code><br/>
<code>#include &lt;glib/gstdio.h&gt;</code><br/>
<code>#include &lt;netdb.h&gt;</code><br/>
<code>#include &lt;netinet/in.h&gt;</code><br/>
<code>#include &lt;netinet/tcp.h&gt;</code><br/>
<code>#include &lt;openssl/ssl.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;sys/resource.h&gt;</code><br/>
<code>#include &lt;sys/socket.h&gt;</code><br/>
<code>#include &lt;sys/times.h&gt;</code><br/>
<code>#include &lt;sys/types.h&gt;</code><br/>
<code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="bench_8h_source.html">bench.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="buffer_8h_source.html">buffer.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cleanup_8h_source.html">cleanup.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="lib_2quick-event_2src_2config_8h_source.html">config.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="fair_8h_source.html">fair.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="job_8h_source.html">job.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="json_8h_source.html">json.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="latch_8h_source.html">latch.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="list_8h_source.html">list.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="lock_8h_source.html">lock.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="log_8h_source.html">log.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="mock_8h_source.html">mock.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="pool_8h_source.html">pool.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="queue_8h_source.html">queue.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="rsock_8h_source.html">rsock.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="safe_8h_source.html">safe.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="stats_8h_source.html">stats.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="strfuncs_8h_source.html">strfuncs.h</a>&quot;</code><br/>
</div>
<p><a href="qev_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqev__flags.html">qev_flags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any flags associated with a client.  <a href="structqev__flags.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqev__client.html">qev_client</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all of the information needed for quick-event to have a functioning client.  <a href="structqev__client.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1a4619ff84173548a2f981326f1576a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a4619ff84173548a2f981326f1576a9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a1a4619ff84173548a2f981326f1576a9">GLIB_VERSION_MIN_REQUIRED</a>&#160;&#160;&#160;GLIB_VERSION_2_32</td></tr>
<tr class="memdesc:a1a4619ff84173548a2f981326f1576a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only allow glib 2.32 as that's the highest on Debian Wheezy. <br/></td></tr>
<tr class="separator:a1a4619ff84173548a2f981326f1576a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd859ad814056b87795aa7926cbd180"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dd859ad814056b87795aa7926cbd180"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a0dd859ad814056b87795aa7926cbd180">GLIB_VERSION_MAX_ALLOWED</a>&#160;&#160;&#160;GLIB_VERSION_2_32</td></tr>
<tr class="memdesc:a0dd859ad814056b87795aa7926cbd180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only allow glib 2.32 as that's the highest on Debian Wheezy. <br/></td></tr>
<tr class="separator:a0dd859ad814056b87795aa7926cbd180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369266c24eacffb87046522897a570d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a369266c24eacffb87046522897a570d5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a369266c24eacffb87046522897a570d5">_GNU_SOURCE</a></td></tr>
<tr class="memdesc:a369266c24eacffb87046522897a570d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give us access to more features. <br/></td></tr>
<tr class="separator:a369266c24eacffb87046522897a570d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7905d71dae5729d2245da88ee501284"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7905d71dae5729d2245da88ee501284"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#af7905d71dae5729d2245da88ee501284">QEV_VERSION_MAJOR</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:af7905d71dae5729d2245da88ee501284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current major version of quick-event. <br/></td></tr>
<tr class="separator:af7905d71dae5729d2245da88ee501284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250d49db10a8b5df0d768d179f239dc4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a250d49db10a8b5df0d768d179f239dc4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a250d49db10a8b5df0d768d179f239dc4">QEV_VERSION_MINOR</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a250d49db10a8b5df0d768d179f239dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current minor version of quick-event. <br/></td></tr>
<tr class="separator:a250d49db10a8b5df0d768d179f239dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89e89980d7cce2647dbe148b812001e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab89e89980d7cce2647dbe148b812001e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#ab89e89980d7cce2647dbe148b812001e">QEV_VERSION_MICRO</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ab89e89980d7cce2647dbe148b812001e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current micro version of quick-event. <br/></td></tr>
<tr class="separator:ab89e89980d7cce2647dbe148b812001e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6b33e60d027eacf28ed3c94efcd47c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f6b33e60d027eacf28ed3c94efcd47c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a0f6b33e60d027eacf28ed3c94efcd47c">VERSION_NAME</a>&#160;&#160;&#160;UNKNOWN</td></tr>
<tr class="memdesc:a0f6b33e60d027eacf28ed3c94efcd47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the application being compiled with the server. <br/></td></tr>
<tr class="separator:a0f6b33e60d027eacf28ed3c94efcd47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a53b724b6de666faa8a9e0d06d1055f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a53b724b6de666faa8a9e0d06d1055f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a1a53b724b6de666faa8a9e0d06d1055f">VERSION_MAJOR</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a1a53b724b6de666faa8a9e0d06d1055f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Major version application being compiled with the server. <br/></td></tr>
<tr class="separator:a1a53b724b6de666faa8a9e0d06d1055f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cb52afb79b185b1bf82c7e235f682b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0cb52afb79b185b1bf82c7e235f682b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#ae0cb52afb79b185b1bf82c7e235f682b">VERSION_MINOR</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ae0cb52afb79b185b1bf82c7e235f682b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minor version application being compiled with the server. <br/></td></tr>
<tr class="separator:ae0cb52afb79b185b1bf82c7e235f682b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1a2edfd65daac37445fb23267f4b8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c1a2edfd65daac37445fb23267f4b8a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a7c1a2edfd65daac37445fb23267f4b8a">VERSION_MICRO</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a7c1a2edfd65daac37445fb23267f4b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Micro version application being compiled with the server. <br/></td></tr>
<tr class="separator:a7c1a2edfd65daac37445fb23267f4b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbb319f674697adf1612ad2a638ade9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fbb319f674697adf1612ad2a638ade9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a7fbb319f674697adf1612ad2a638ade9">QEV_SSL_CIPHERS</a>&#160;&#160;&#160;&quot;HIGH:!aNULL:!MD5:&quot;</td></tr>
<tr class="memdesc:a7fbb319f674697adf1612ad2a638ade9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whatever ciphers SSL should use. <br/></td></tr>
<tr class="separator:a7fbb319f674697adf1612ad2a638ade9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8413775ba81d4752959dfaaa6af560"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b8413775ba81d4752959dfaaa6af560"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a>&#160;&#160;&#160;<a class="el" href="structqev__client.html">qev_client</a></td></tr>
<tr class="memdesc:a5b8413775ba81d4752959dfaaa6af560"><td class="mdescLeft">&#160;</td><td class="mdescRight">If no client was configured externally, default to <a class="el" href="structqev__client.html" title="Contains all of the information needed for quick-event to have a functioning client. ">qev_client</a>. <br/></td></tr>
<tr class="separator:a5b8413775ba81d4752959dfaaa6af560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05fc025c0fb261499ff90bfed005b9e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#ad05fc025c0fb261499ff90bfed005b9e">QEV_MS_TO_USEC</a>(ms)&#160;&#160;&#160;(ms * 1000)</td></tr>
<tr class="memdesc:ad05fc025c0fb261499ff90bfed005b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert milliseconds to microseconds.  <a href="#ad05fc025c0fb261499ff90bfed005b9e">More...</a><br/></td></tr>
<tr class="separator:ad05fc025c0fb261499ff90bfed005b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bdb1f1afebcaf42256b4decdfa750e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a44bdb1f1afebcaf42256b4decdfa750e">QEV_MS_TO_NSEC</a>(ms)&#160;&#160;&#160;(<a class="el" href="qev_8h.html#ad05fc025c0fb261499ff90bfed005b9e">QEV_MS_TO_USEC</a>(ms) * 1000)</td></tr>
<tr class="memdesc:a44bdb1f1afebcaf42256b4decdfa750e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert milliseconds to nanoseconds.  <a href="#a44bdb1f1afebcaf42256b4decdfa750e">More...</a><br/></td></tr>
<tr class="separator:a44bdb1f1afebcaf42256b4decdfa750e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527c74ef033dfae4f9eafe24c39015a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a527c74ef033dfae4f9eafe24c39015a9">QEV_SEC_TO_USEC</a>(secs)&#160;&#160;&#160;<a class="el" href="qev_8h.html#ad05fc025c0fb261499ff90bfed005b9e">QEV_MS_TO_USEC</a>(secs * 1000)</td></tr>
<tr class="memdesc:a527c74ef033dfae4f9eafe24c39015a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert seconds to microseconds.  <a href="#a527c74ef033dfae4f9eafe24c39015a9">More...</a><br/></td></tr>
<tr class="separator:a527c74ef033dfae4f9eafe24c39015a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5c30692b8fdde191d29d86c6f48120"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee5c30692b8fdde191d29d86c6f48120"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#aee5c30692b8fdde191d29d86c6f48120">QEV_YIELD_AFTER</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memdesc:aee5c30692b8fdde191d29d86c6f48120"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of spins anything should yield after. <br/></td></tr>
<tr class="separator:aee5c30692b8fdde191d29d86c6f48120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16996f10356dc8ef4d023990b3a9643d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a16996f10356dc8ef4d023990b3a9643d">QEV_WAIT_FOR</a>(cond)</td></tr>
<tr class="memdesc:a16996f10356dc8ef4d023990b3a9643d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for a condition to be true, yielding in the process if it waits too long.  <a href="#a16996f10356dc8ef4d023990b3a9643d">More...</a><br/></td></tr>
<tr class="separator:a16996f10356dc8ef4d023990b3a9643d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aac67e019c25637600e2f82ff72d61c69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac67e019c25637600e2f82ff72d61c69"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#aac67e019c25637600e2f82ff72d61c69">qev_fd_t</a></td></tr>
<tr class="memdesc:aac67e019c25637600e2f82ff72d61c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sockets are just ints. <br/></td></tr>
<tr class="separator:aac67e019c25637600e2f82ff72d61c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da5ae1902f109059dcbedd768730987"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6da5ae1902f109059dcbedd768730987"></a>
typedef struct <a class="el" href="qev_8h.html#ae15165fdf5186dca35cf6a9fcf0876ce">qev_timeout</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a6da5ae1902f109059dcbedd768730987">qev_timeout_t</a></td></tr>
<tr class="memdesc:a6da5ae1902f109059dcbedd768730987"><td class="mdescLeft">&#160;</td><td class="mdescRight">You're never allowed to mess with timeout internals. <br/></td></tr>
<tr class="separator:a6da5ae1902f109059dcbedd768730987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d7c0d364033b754c3636a8d5604546"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01d7c0d364033b754c3636a8d5604546"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a01d7c0d364033b754c3636a8d5604546">qev_cb</a> )()</td></tr>
<tr class="memdesc:a01d7c0d364033b754c3636a8d5604546"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single callback that takes nothing and returns nothing. <br/></td></tr>
<tr class="separator:a01d7c0d364033b754c3636a8d5604546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e29aa904c50e484402e27c833f28b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0e29aa904c50e484402e27c833f28b6"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#ab0e29aa904c50e484402e27c833f28b6">qev_free_fn</a> )(void *)</td></tr>
<tr class="memdesc:ab0e29aa904c50e484402e27c833f28b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type for a typical free function. <br/></td></tr>
<tr class="separator:ab0e29aa904c50e484402e27c833f28b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c809f55b4bc395231834524b5e4062d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c809f55b4bc395231834524b5e4062d"></a>
typedef <a class="el" href="qev_8h.html#ab0e29aa904c50e484402e27c833f28b6">qev_free_fn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a7c809f55b4bc395231834524b5e4062d">qev_data_cb</a></td></tr>
<tr class="memdesc:a7c809f55b4bc395231834524b5e4062d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type for something that recieves an argument. <br/></td></tr>
<tr class="separator:a7c809f55b4bc395231834524b5e4062d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae588f0b11326b9428ea6e09c0c0ab25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae588f0b11326b9428ea6e09c0c0ab25"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#aae588f0b11326b9428ea6e09c0c0ab25">qev_client_cb</a> )(struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *<a class="el" href="structclient.html">client</a>, void *data)</td></tr>
<tr class="memdesc:aae588f0b11326b9428ea6e09c0c0ab25"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback that takes a single client. <br/></td></tr>
<tr class="separator:aae588f0b11326b9428ea6e09c0c0ab25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a944f659ef0d34c904ab83cf438f54843"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a944f659ef0d34c904ab83cf438f54843">qev_close_reasons</a> { <br/>
&#160;&#160;<a class="el" href="qev_8h.html#a944f659ef0d34c904ab83cf438f54843acef256fb22d7d3f0eb9a39588de3b123">QEV_CLOSE_HUP</a>, 
<a class="el" href="qev_8h.html#a944f659ef0d34c904ab83cf438f54843a3e2b8671c1db10ba18667a4e88decd88">QEV_CLOSE_READ_FAIL</a>, 
<a class="el" href="qev_8h.html#a944f659ef0d34c904ab83cf438f54843a28af564d9d719d01586542e1328dd9e1">QEV_CLOSE_TIMEOUT</a>, 
<a class="el" href="qev_8h.html#a944f659ef0d34c904ab83cf438f54843a6dce2287e206095ebd03c4617ffee5db">QEV_CLOSE_OS_ERROR</a>, 
<br/>
&#160;&#160;<a class="el" href="qev_8h.html#a944f659ef0d34c904ab83cf438f54843a0de5d10424ba2a5ea75951f35342a15e">QEV_CLOSE_OUT_OF_MEM</a>, 
<a class="el" href="qev_8h.html#a944f659ef0d34c904ab83cf438f54843a986185a0f9d73910c0708dfa162daa9f">QEV_CLOSE_EXITING</a>, 
<a class="el" href="qev_8h.html#a944f659ef0d34c904ab83cf438f54843a58621d5eda359c0ae0309d9007982668">QEV_CLOSE_LEN</a>
<br/>
 }</td></tr>
<tr class="memdesc:a944f659ef0d34c904ab83cf438f54843"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reasons a client might be closed.  <a href="qev_8h.html#a944f659ef0d34c904ab83cf438f54843">More...</a><br/></td></tr>
<tr class="separator:a944f659ef0d34c904ab83cf438f54843"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af433395f8fd4cb5c18fc0077c6c1821f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#af433395f8fd4cb5c18fc0077c6c1821f">qev_init</a> (const gchar *app_name, gchar **argv, gint argc)</td></tr>
<tr class="memdesc:af433395f8fd4cb5c18fc0077c6c1821f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares QEV to run.  <a href="#af433395f8fd4cb5c18fc0077c6c1821f">More...</a><br/></td></tr>
<tr class="separator:af433395f8fd4cb5c18fc0077c6c1821f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf8815c02f0bbb4472ca3797eab3efd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecf8815c02f0bbb4472ca3797eab3efd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#aecf8815c02f0bbb4472ca3797eab3efd">qev_run</a> ()</td></tr>
<tr class="memdesc:aecf8815c02f0bbb4472ca3797eab3efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns all worker threads and starts QEV running. <br/></td></tr>
<tr class="separator:aecf8815c02f0bbb4472ca3797eab3efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b853d615bbd5ce09bc2dfa730febceb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a2b853d615bbd5ce09bc2dfa730febceb">qev_kill</a> ()</td></tr>
<tr class="memdesc:a2b853d615bbd5ce09bc2dfa730febceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unblocks all threads waiting for QEV to exit.  <a href="#a2b853d615bbd5ce09bc2dfa730febceb">More...</a><br/></td></tr>
<tr class="separator:a2b853d615bbd5ce09bc2dfa730febceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7977ee0344f557d3c1e6fa8eb41c2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#abd7977ee0344f557d3c1e6fa8eb41c2d">qev_wait_for_exit</a> ()</td></tr>
<tr class="memdesc:abd7977ee0344f557d3c1e6fa8eb41c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows you to wait for QEV to exit; really, this is a way to block the main thread while QEV is running.  <a href="#abd7977ee0344f557d3c1e6fa8eb41c2d">More...</a><br/></td></tr>
<tr class="separator:abd7977ee0344f557d3c1e6fa8eb41c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c6cf9f6529fa952c9d167195ddd6a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#ab3c6cf9f6529fa952c9d167195ddd6a3">qev_exit</a> ()</td></tr>
<tr class="memdesc:ab3c6cf9f6529fa952c9d167195ddd6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kill and wait for QEV to exit in one fell swoop.  <a href="#ab3c6cf9f6529fa952c9d167195ddd6a3">More...</a><br/></td></tr>
<tr class="separator:ab3c6cf9f6529fa952c9d167195ddd6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1cebfadef1f99799156106551418cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a9a1cebfadef1f99799156106551418cb">qev_listen</a> (const gchar *ip_address, const guint16 port)</td></tr>
<tr class="memdesc:a9a1cebfadef1f99799156106551418cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruct quick event to listen on a socket for connections and route them into the event handler.  <a href="#a9a1cebfadef1f99799156106551418cb">More...</a><br/></td></tr>
<tr class="separator:a9a1cebfadef1f99799156106551418cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3eecf6974eb7eec71a9905ec1d60ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#abe3eecf6974eb7eec71a9905ec1d60ad">qev_listen_ssl</a> (const gchar *ip_address, const guint16 port, const gchar *cert_path0, const gchar *key_path0, const gchar *cert_path1, const gchar *key_path1)</td></tr>
<tr class="memdesc:abe3eecf6974eb7eec71a9905ec1d60ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruct quick event to listen on an SSL socket for connections and route them into the event handler.  <a href="#abe3eecf6974eb7eec71a9905ec1d60ad">More...</a><br/></td></tr>
<tr class="separator:abe3eecf6974eb7eec71a9905ec1d60ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ef3d34b7758405e346c62204d45c2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a15ef3d34b7758405e346c62204d45c2a">qev_listen_unix</a> (const gchar *path)</td></tr>
<tr class="memdesc:a15ef3d34b7758405e346c62204d45c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruct quick event to create a Unix socket at the given path and listen on it.  <a href="#a15ef3d34b7758405e346c62204d45c2a">More...</a><br/></td></tr>
<tr class="separator:a15ef3d34b7758405e346c62204d45c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c22123de090379112e3b4b2d17cef4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#ae4c22123de090379112e3b4b2d17cef4">qev_listen_udp</a> (const gchar *ip_address, const guint16 port)</td></tr>
<tr class="memdesc:ae4c22123de090379112e3b4b2d17cef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruct quick event to listen on on a UDP socket for messages.  <a href="#ae4c22123de090379112e3b4b2d17cef4">More...</a><br/></td></tr>
<tr class="separator:ae4c22123de090379112e3b4b2d17cef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4cc46c84dfb7ff86b7ca8e5e817afe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d4cc46c84dfb7ff86b7ca8e5e817afe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a2d4cc46c84dfb7ff86b7ca8e5e817afe">qev_chuser</a> (const char *username)</td></tr>
<tr class="memdesc:a2d4cc46c84dfb7ff86b7ca8e5e817afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run as this user. <br/></td></tr>
<tr class="separator:a2d4cc46c84dfb7ff86b7ca8e5e817afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cc19854a4663e6918c335f8b74a642"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a83cc19854a4663e6918c335f8b74a642">qev_setnofile</a> (const gint nofile)</td></tr>
<tr class="memdesc:a83cc19854a4663e6918c335f8b74a642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the limits for the number of open files for this process.  <a href="#a83cc19854a4663e6918c335f8b74a642">More...</a><br/></td></tr>
<tr class="separator:a83cc19854a4663e6918c335f8b74a642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbe1b33b3382bfefe4515c863f6f6c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#abcbe1b33b3382bfefe4515c863f6f6c3">qev_timer</a> (const <a class="el" href="qev_8h.html#a01d7c0d364033b754c3636a8d5604546">qev_cb</a> fn, const guint seconds, const guint ms)</td></tr>
<tr class="memdesc:abcbe1b33b3382bfefe4515c863f6f6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a callback to be fired on a timer.  <a href="#abcbe1b33b3382bfefe4515c863f6f6c3">More...</a><br/></td></tr>
<tr class="separator:abcbe1b33b3382bfefe4515c863f6f6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba6257c3ca10ef2ca594b44c1db4b68"><td class="memItemLeft" align="right" valign="top">const gchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a1ba6257c3ca10ef2ca594b44c1db4b68">qev_get_hostname</a> ()</td></tr>
<tr class="memdesc:a1ba6257c3ca10ef2ca594b44c1db4b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of this host.  <a href="#a1ba6257c3ca10ef2ca594b44c1db4b68">More...</a><br/></td></tr>
<tr class="separator:a1ba6257c3ca10ef2ca594b44c1db4b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af231495c7ec8db41bc52beb4b72df057"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#af231495c7ec8db41bc52beb4b72df057">qev_surrogate_new</a> ()</td></tr>
<tr class="memdesc:af231495c7ec8db41bc52beb4b72df057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a surrogate client.  <a href="#af231495c7ec8db41bc52beb4b72df057">More...</a><br/></td></tr>
<tr class="separator:af231495c7ec8db41bc52beb4b72df057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e8185700f3e0fb2663606f986e9c7a"><td class="memItemLeft" align="right" valign="top">GString *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#ab6e8185700f3e0fb2663606f986e9c7a">qev_surrogate_flush</a> (struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *surrogate)</td></tr>
<tr class="memdesc:ab6e8185700f3e0fb2663606f986e9c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Steal the entire write buffer from the surrogate client.  <a href="#ab6e8185700f3e0fb2663606f986e9c7a">More...</a><br/></td></tr>
<tr class="separator:ab6e8185700f3e0fb2663606f986e9c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cec6f518c31ba7fbf802b88082091a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a24cec6f518c31ba7fbf802b88082091a">qev_write</a> (struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *<a class="el" href="structclient.html">client</a>, const gchar *buff, const gsize len)</td></tr>
<tr class="memdesc:a24cec6f518c31ba7fbf802b88082091a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to the client.  <a href="#a24cec6f518c31ba7fbf802b88082091a">More...</a><br/></td></tr>
<tr class="separator:a24cec6f518c31ba7fbf802b88082091a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65edb890b3885a2e11d243308276fb72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a65edb890b3885a2e11d243308276fb72">qev_writef</a> (struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *<a class="el" href="structclient.html">client</a>, const gchar *format,...) G_GNUC_PRINTF(2</td></tr>
<tr class="memdesc:a65edb890b3885a2e11d243308276fb72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows you to use qev_write in a printf() style.  <a href="#a65edb890b3885a2e11d243308276fb72">More...</a><br/></td></tr>
<tr class="separator:a65edb890b3885a2e11d243308276fb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426977689619a70cd6827d6f9e196912"><td class="memItemLeft" align="right" valign="top">void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a426977689619a70cd6827d6f9e196912">qev_close</a> (struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *<a class="el" href="structclient.html">client</a>, guint reason)</td></tr>
<tr class="memdesc:a426977689619a70cd6827d6f9e196912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close and free the client when it is safe to do so.  <a href="#a426977689619a70cd6827d6f9e196912">More...</a><br/></td></tr>
<tr class="separator:a426977689619a70cd6827d6f9e196912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa83957d3a828ec16a30238837917a53"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#aaa83957d3a828ec16a30238837917a53">qev_is_surrogate</a> (struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *<a class="el" href="structclient.html">client</a>)</td></tr>
<tr class="memdesc:aaa83957d3a828ec16a30238837917a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a client is a surrogate.  <a href="#aaa83957d3a828ec16a30238837917a53">More...</a><br/></td></tr>
<tr class="separator:aaa83957d3a828ec16a30238837917a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad512aaedacb2a48cfe78b9d646c600d9"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#ad512aaedacb2a48cfe78b9d646c600d9">qev_is_closing</a> (struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *<a class="el" href="structclient.html">client</a>)</td></tr>
<tr class="memdesc:ad512aaedacb2a48cfe78b9d646c600d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a client is closing.  <a href="#ad512aaedacb2a48cfe78b9d646c600d9">More...</a><br/></td></tr>
<tr class="separator:ad512aaedacb2a48cfe78b9d646c600d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2390a5e39ee6880f6189c1c2ad1a2cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a2390a5e39ee6880f6189c1c2ad1a2cb1">qev_foreach</a> (<a class="el" href="qev_8h.html#aae588f0b11326b9428ea6e09c0c0ab25">qev_client_cb</a> cb, gint threads, void *data)</td></tr>
<tr class="memdesc:a2390a5e39ee6880f6189c1c2ad1a2cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the callback on all clients.  <a href="#a2390a5e39ee6880f6189c1c2ad1a2cb1">More...</a><br/></td></tr>
<tr class="separator:a2390a5e39ee6880f6189c1c2ad1a2cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696fcc1126f660cf74c0137533531fe3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a696fcc1126f660cf74c0137533531fe3"></a>
struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a696fcc1126f660cf74c0137533531fe3">qev_ref</a> (struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *<a class="el" href="structclient.html">client</a>)</td></tr>
<tr class="memdesc:a696fcc1126f660cf74c0137533531fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a reference to the client. <br/></td></tr>
<tr class="separator:a696fcc1126f660cf74c0137533531fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3527e3ab079ed8d05dfba6984b5423e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3527e3ab079ed8d05dfba6984b5423e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a3527e3ab079ed8d05dfba6984b5423e2">qev_unref</a> (struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *<a class="el" href="structclient.html">client</a>)</td></tr>
<tr class="memdesc:a3527e3ab079ed8d05dfba6984b5423e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a reference to the client. <br/></td></tr>
<tr class="separator:a3527e3ab079ed8d05dfba6984b5423e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4fdbceb55617d81dbec58571e13c092"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4fdbceb55617d81dbec58571e13c092"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#ac4fdbceb55617d81dbec58571e13c092">qev_unref0</a> (struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> **<a class="el" href="structclient.html">client</a>)</td></tr>
<tr class="memdesc:ac4fdbceb55617d81dbec58571e13c092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a reference to the client and set the corresponding memory location to NULL. <br/></td></tr>
<tr class="separator:ac4fdbceb55617d81dbec58571e13c092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7581a3ed897f737a39af99d41b32db3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7581a3ed897f737a39af99d41b32db3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#ac7581a3ed897f737a39af99d41b32db3">qev_unref_as_free</a> (void *client_)</td></tr>
<tr class="memdesc:ac7581a3ed897f737a39af99d41b32db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">So that you can use it as a free function without a cast. <br/></td></tr>
<tr class="separator:ac7581a3ed897f737a39af99d41b32db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8f634422145a23236cea847c43e465"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a1b8f634422145a23236cea847c43e465">qev_lock</a> (struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *<a class="el" href="structclient.html">client</a>)</td></tr>
<tr class="memdesc:a1b8f634422145a23236cea847c43e465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire a lock on a client.  <a href="#a1b8f634422145a23236cea847c43e465">More...</a><br/></td></tr>
<tr class="separator:a1b8f634422145a23236cea847c43e465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcd132e1dfc4f0e49e3f021a04dffe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#abdcd132e1dfc4f0e49e3f021a04dffe7">qev_unlock</a> (struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *<a class="el" href="structclient.html">client</a>)</td></tr>
<tr class="memdesc:abdcd132e1dfc4f0e49e3f021a04dffe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a lock on a client.  <a href="#abdcd132e1dfc4f0e49e3f021a04dffe7">More...</a><br/></td></tr>
<tr class="separator:abdcd132e1dfc4f0e49e3f021a04dffe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15165fdf5186dca35cf6a9fcf0876ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#ae15165fdf5186dca35cf6a9fcf0876ce">qev_timeout</a> (struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *<a class="el" href="structclient.html">client</a>, <a class="el" href="qev_8h.html#a6da5ae1902f109059dcbedd768730987">qev_timeout_t</a> **timeout)</td></tr>
<tr class="memdesc:ae15165fdf5186dca35cf6a9fcf0876ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a timeout on a client.  <a href="#ae15165fdf5186dca35cf6a9fcf0876ce">More...</a><br/></td></tr>
<tr class="separator:ae15165fdf5186dca35cf6a9fcf0876ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3bbc94c29c04dd0fda08772843f78f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#aac3bbc94c29c04dd0fda08772843f78f">qev_timeout_clear</a> (<a class="el" href="qev_8h.html#a6da5ae1902f109059dcbedd768730987">qev_timeout_t</a> **timeout)</td></tr>
<tr class="memdesc:aac3bbc94c29c04dd0fda08772843f78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a timeout on a client and release your reference to the timeout.  <a href="#aac3bbc94c29c04dd0fda08772843f78f">More...</a><br/></td></tr>
<tr class="separator:aac3bbc94c29c04dd0fda08772843f78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ca5279c10e17b9d404081dcd042f59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#ae5ca5279c10e17b9d404081dcd042f59">qev_chuser</a> (const gchar *username)</td></tr>
<tr class="memdesc:ae5ca5279c10e17b9d404081dcd042f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change to a different user.  <a href="#ae5ca5279c10e17b9d404081dcd042f59">More...</a><br/></td></tr>
<tr class="separator:ae5ca5279c10e17b9d404081dcd042f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa112896c86eb3f3df9611154e5735cf3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa112896c86eb3f3df9611154e5735cf3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#aa112896c86eb3f3df9611154e5735cf3">qev_on_before_run</a> ()</td></tr>
<tr class="memdesc:aa112896c86eb3f3df9611154e5735cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Before the server is about to run (right before when the QEV threads are set into the event loop), this function will be executed to allow you to create pools, do app init, and all that good stuff. <br/></td></tr>
<tr class="separator:aa112896c86eb3f3df9611154e5735cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3f970d0f8798f00a4af312392982b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#aed3f970d0f8798f00a4af312392982b0">qev_on_open</a> (struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *<a class="el" href="structclient.html">client</a>)</td></tr>
<tr class="memdesc:aed3f970d0f8798f00a4af312392982b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification that a new client was accepted.  <a href="#aed3f970d0f8798f00a4af312392982b0">More...</a><br/></td></tr>
<tr class="separator:aed3f970d0f8798f00a4af312392982b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaefa0e5f5d5cb86abcb733b5e3ecaf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#adaefa0e5f5d5cb86abcb733b5e3ecaf1">qev_on_close</a> (struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *<a class="el" href="structclient.html">client</a>, guint reason)</td></tr>
<tr class="memdesc:adaefa0e5f5d5cb86abcb733b5e3ecaf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification that a client has closed / been closed.  <a href="#adaefa0e5f5d5cb86abcb733b5e3ecaf1">More...</a><br/></td></tr>
<tr class="separator:adaefa0e5f5d5cb86abcb733b5e3ecaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953d3480791333ad301b54ff1ddc702e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a953d3480791333ad301b54ff1ddc702e">qev_on_read</a> (struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *<a class="el" href="structclient.html">client</a>)</td></tr>
<tr class="memdesc:a953d3480791333ad301b54ff1ddc702e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A notification that the client has data for reading.  <a href="#a953d3480791333ad301b54ff1ddc702e">More...</a><br/></td></tr>
<tr class="separator:a953d3480791333ad301b54ff1ddc702e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713ffbf3ddf74e30fa09592a1cd3a387"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a713ffbf3ddf74e30fa09592a1cd3a387">qev_on_udp</a> (const gchar *msg, const gsize len, const gchar *ip)</td></tr>
<tr class="memdesc:a713ffbf3ddf74e30fa09592a1cd3a387"><td class="mdescLeft">&#160;</td><td class="mdescRight">A notification that there is a new UDP message waiting.  <a href="#a713ffbf3ddf74e30fa09592a1cd3a387">More...</a><br/></td></tr>
<tr class="separator:a713ffbf3ddf74e30fa09592a1cd3a387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c703f9b2602437fd10d96d89f1cd719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a3c703f9b2602437fd10d96d89f1cd719">qev_on_tick</a> ()</td></tr>
<tr class="memdesc:a3c703f9b2602437fd10d96d89f1cd719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fired after every iteration of the event loop from every QEV thread.  <a href="#a3c703f9b2602437fd10d96d89f1cd719">More...</a><br/></td></tr>
<tr class="separator:a3c703f9b2602437fd10d96d89f1cd719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1984a0000bead164543cc55643c2505"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#ae1984a0000bead164543cc55643c2505">qev_on_exit</a> ()</td></tr>
<tr class="memdesc:ae1984a0000bead164543cc55643c2505"><td class="mdescLeft">&#160;</td><td class="mdescRight">A notification that QEV is going to shut down.  <a href="#ae1984a0000bead164543cc55643c2505">More...</a><br/></td></tr>
<tr class="separator:ae1984a0000bead164543cc55643c2505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d79d66456b986cd9c28f0b617f9bb0"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#ae1d79d66456b986cd9c28f0b617f9bb0">qev_client_new</a> ()</td></tr>
<tr class="memdesc:ae1d79d66456b986cd9c28f0b617f9bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new client using whatever memory allocator you wish and sized appropriately for your needs.  <a href="#ae1d79d66456b986cd9c28f0b617f9bb0">More...</a><br/></td></tr>
<tr class="separator:ae1d79d66456b986cd9c28f0b617f9bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff2fd62bc893e1ec0e35bccf9dc2187"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a4ff2fd62bc893e1ec0e35bccf9dc2187">qev_client_free</a> (struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *<a class="el" href="structclient.html">client</a>)</td></tr>
<tr class="memdesc:a4ff2fd62bc893e1ec0e35bccf9dc2187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the client allocated with <a class="el" href="qev_8h.html#ae1d79d66456b986cd9c28f0b617f9bb0" title="Create a new client using whatever memory allocator you wish and sized appropriately for your needs...">qev_client_new()</a>.  <a href="#a4ff2fd62bc893e1ec0e35bccf9dc2187">More...</a><br/></td></tr>
<tr class="separator:a4ff2fd62bc893e1ec0e35bccf9dc2187"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aca37f88aecf2ca08c36acb4e80809f00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca37f88aecf2ca08c36acb4e80809f00"></a>
gint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#aca37f88aecf2ca08c36acb4e80809f00">qev_time</a></td></tr>
<tr class="memdesc:aca37f88aecf2ca08c36acb4e80809f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">An approximation of the current time, set from g_get_real_time(), updated at least every 100ms. <br/></td></tr>
<tr class="separator:aca37f88aecf2ca08c36acb4e80809f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332bb7d10bc3261fc70da53793f73ede"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a332bb7d10bc3261fc70da53793f73ede"></a>
gint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qev_8h.html#a332bb7d10bc3261fc70da53793f73ede">qev_monotonic</a></td></tr>
<tr class="memdesc:a332bb7d10bc3261fc70da53793f73ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">An approximate monotonic time, set from g_get_monotonic_time(), updated at least every 100ms. <br/></td></tr>
<tr class="separator:a332bb7d10bc3261fc70da53793f73ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides all the qev_* functions that are needed for creating an event loop. </p>
<p>In order to interact with QEV, you're required to create the following functions in your program in a way that QEV can see them: 0) <a class="el" href="qev_8h.html#aa112896c86eb3f3df9611154e5735cf3" title="Before the server is about to run (right before when the QEV threads are set into the event loop)...">qev_on_before_run()</a>; 1) <a class="el" href="qev_8h.html#aed3f970d0f8798f00a4af312392982b0" title="Notification that a new client was accepted. ">qev_on_open(struct QEV_CLIENT *client)</a>; 2) <a class="el" href="qev_8h.html#adaefa0e5f5d5cb86abcb733b5e3ecaf1" title="Notification that a client has closed / been closed. ">qev_on_close(struct QEV_CLIENT *client, guint reason)</a>; 3) <a class="el" href="qev_8h.html#a953d3480791333ad301b54ff1ddc702e" title="A notification that the client has data for reading. ">qev_on_read(struct QEV_CLIENT *client)</a>; 4) qev_on_udp(const gchar *msg, const gssize len, const gchar *ip); 5) <a class="el" href="qev_8h.html#a3c703f9b2602437fd10d96d89f1cd719" title="Fired after every iteration of the event loop from every QEV thread. ">qev_on_tick()</a>; 6) <a class="el" href="qev_8h.html#ae1984a0000bead164543cc55643c2505" title="A notification that QEV is going to shut down. ">qev_on_exit()</a>; 7) <a class="el" href="qev_8h.html#ae1d79d66456b986cd9c28f0b617f9bb0" title="Create a new client using whatever memory allocator you wish and sized appropriately for your needs...">qev_client_new()</a>; 8) <a class="el" href="qev_8h.html#a4ff2fd62bc893e1ec0e35bccf9dc2187" title="Free the client allocated with qev_client_new(). ">qev_client_free(struct QEV_CLIENT *client)</a>;</p>
<p>See the function definitions for information about what each function does.</p>
<dl class="section author"><dt>Author</dt><dd>Andrew Stone <a href="#" onclick="location.href='mai'+'lto:'+'and'+'re'+'w@c'+'lo'+'var'+'.c'+'om'; return false;">andre<span style="display: none;">.nosp@m.</span>w@cl<span style="display: none;">.nosp@m.</span>ovar.<span style="display: none;">.nosp@m.</span>com</a> </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2012-2014 Clear Channel Inc. </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a44bdb1f1afebcaf42256b4decdfa750e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QEV_MS_TO_NSEC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ms</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="qev_8h.html#ad05fc025c0fb261499ff90bfed005b9e">QEV_MS_TO_USEC</a>(ms) * 1000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert milliseconds to nanoseconds. </p>
<p>Just so it's easier to read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>The number of milliseconds to put into nanoseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad05fc025c0fb261499ff90bfed005b9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QEV_MS_TO_USEC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ms</td><td>)</td>
          <td>&#160;&#160;&#160;(ms * 1000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert milliseconds to microseconds. </p>
<p>Just so it's easier to read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>The number of milliseconds to put into microseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a527c74ef033dfae4f9eafe24c39015a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QEV_SEC_TO_USEC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">secs</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="qev_8h.html#ad05fc025c0fb261499ff90bfed005b9e">QEV_MS_TO_USEC</a>(secs * 1000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert seconds to microseconds. </p>
<p>Just so it's easier to read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">secs</td><td>The number of seconds to put into microseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16996f10356dc8ef4d023990b3a9643d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QEV_WAIT_FOR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cond</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div>
<div class="line">        register guint spins = 0; \</div>
<div class="line">        while (!(cond)) { \</div>
<div class="line">                if (++spins &gt; <a class="code" href="qev_8h.html#aee5c30692b8fdde191d29d86c6f48120">QEV_YIELD_AFTER</a>) { \</div>
<div class="line">                        g_thread_yield(); \</div>
<div class="line">                } \</div>
<div class="line">        }}</div>
<div class="ttc" id="qev_8h_html_aee5c30692b8fdde191d29d86c6f48120"><div class="ttname"><a href="qev_8h.html#aee5c30692b8fdde191d29d86c6f48120">QEV_YIELD_AFTER</a></div><div class="ttdeci">#define QEV_YIELD_AFTER</div><div class="ttdoc">The number of spins anything should yield after. </div><div class="ttdef"><b>Definition:</b> qev.h:153</div></div>
</div><!-- fragment -->
<p>Waits for a condition to be true, yielding in the process if it waits too long. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a944f659ef0d34c904ab83cf438f54843"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="qev_8h.html#a944f659ef0d34c904ab83cf438f54843">qev_close_reasons</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The reasons a client might be closed. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a944f659ef0d34c904ab83cf438f54843acef256fb22d7d3f0eb9a39588de3b123"></a>QEV_CLOSE_HUP</em>&#160;</td><td class="fielddoc">
<p>The client's socket hung up or timed out. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a944f659ef0d34c904ab83cf438f54843a3e2b8671c1db10ba18667a4e88decd88"></a>QEV_CLOSE_READ_FAIL</em>&#160;</td><td class="fielddoc">
<p>A read failed. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a944f659ef0d34c904ab83cf438f54843a28af564d9d719d01586542e1328dd9e1"></a>QEV_CLOSE_TIMEOUT</em>&#160;</td><td class="fielddoc">
<p>The client timed out. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a944f659ef0d34c904ab83cf438f54843a6dce2287e206095ebd03c4617ffee5db"></a>QEV_CLOSE_OS_ERROR</em>&#160;</td><td class="fielddoc">
<p>A system call failed somewhere and the client must die. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a944f659ef0d34c904ab83cf438f54843a0de5d10424ba2a5ea75951f35342a15e"></a>QEV_CLOSE_OUT_OF_MEM</em>&#160;</td><td class="fielddoc">
<p>Memory pressure has been hit, and the client is being closed as a result. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a944f659ef0d34c904ab83cf438f54843a986185a0f9d73910c0708dfa162daa9f"></a>QEV_CLOSE_EXITING</em>&#160;</td><td class="fielddoc">
<p>The server is exiting and on its way to shutdown. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a944f659ef0d34c904ab83cf438f54843a58621d5eda359c0ae0309d9007982668"></a>QEV_CLOSE_LEN</em>&#160;</td><td class="fielddoc">
<p>The number of items in this enum. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae5ca5279c10e17b9d404081dcd042f59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_chuser </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>username</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change to a different user. </p>
<p>This function will refuse to run as root and return and error if you try to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">username</td><td>The username to run as </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ff2fd62bc893e1ec0e35bccf9dc2187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_client_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the client allocated with <a class="el" href="qev_8h.html#ae1d79d66456b986cd9c28f0b617f9bb0" title="Create a new client using whatever memory allocator you wish and sized appropriately for your needs...">qev_client_new()</a>. </p>
<p>This must be used to completely clean up all memory allocated for the client. </p>

</div>
</div>
<a class="anchor" id="ae1d79d66456b986cd9c28f0b617f9bb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a>* qev_client_new </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new client using whatever memory allocator you wish and sized appropriately for your needs. </p>
<p>The returned client must be zerod out and ready for use. </p>

</div>
</div>
<a class="anchor" id="a426977689619a70cd6827d6f9e196912"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void void qev_close </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close and free the client when it is safe to do so. </p>
<p>After calling this, no more read callbacks will be fired on this client, and you will receive the close callback only when all the underlying polling mechanisms have synced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The client to destroy. </td></tr>
    <tr><td class="paramname">reason</td><td>Why the client is being destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3c6cf9f6529fa952c9d167195ddd6a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_exit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kill and wait for QEV to exit in one fell swoop. </p>
<dl class="section note"><dt>Note</dt><dd>This function will block forever if you call it from a QEV thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a2390a5e39ee6880f6189c1c2ad1a2cb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qev_8h.html#aae588f0b11326b9428ea6e09c0c0ab25">qev_client_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the callback on all clients. </p>
<dl class="section note"><dt>Note</dt><dd>When called from a QEV thread, this function acquires no locks, and it's really rather efficient when compared to calling from a non-QEV thread.</dd>
<dd>
If a client closes while iterating the list, a callback will not be fired for that client. Likewise, if a client connects while iterating, there will be no callback for him. Due to the nature of lock-free iterating, however, it's possible that a client will recieve multiple callbacks, so be ready for that.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The callback to fire </td></tr>
    <tr><td class="paramname">threads</td><td>The number of jobs that should be sent to QEV's thread pool. Less than 0 means use the default number of threads (config value "job-threads"). 0 and 1 mean that no job will be sent and this will execute in a single thread. Anything else is just the number of threads. </td></tr>
    <tr><td class="paramname">data</td><td>Data to give to each callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ba6257c3ca10ef2ca594b44c1db4b68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const gchar* qev_get_hostname </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of this host. </p>
<p>By default, it uses quick-event's config option "hostname" as the value but falls back to g_get_host_name() in the event that that wasn't set. </p>

</div>
</div>
<a class="anchor" id="af433395f8fd4cb5c18fc0077c6c1821f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_init </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>app_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gchar **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint&#160;</td>
          <td class="paramname"><em>argc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares QEV to run. </p>
<p>This function MUST be called before QEV can do anything.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">app_name</td><td>The name of your application. Used for stats reporting, monitoring, and the like. Make sure this is a static string, or you're gonna have a bad time. </td></tr>
    <tr><td class="paramname">argv</td><td>Pretty much main()'s argv </td></tr>
    <tr><td class="paramname">argc</td><td>main()'s argc </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad512aaedacb2a48cfe78b9d646c600d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean qev_is_closing </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a client is closing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The client to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the client is closing </dd></dl>

</div>
</div>
<a class="anchor" id="aaa83957d3a828ec16a30238837917a53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean qev_is_surrogate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a client is a surrogate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The client to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the client is a surrogate </dd></dl>

</div>
</div>
<a class="anchor" id="a2b853d615bbd5ce09bc2dfa730febceb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_kill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unblocks all threads waiting for QEV to exit. </p>
<p>After calling this, at least 1 thread MUST call <a class="el" href="qev_8h.html#abd7977ee0344f557d3c1e6fa8eb41c2d" title="Allows you to wait for QEV to exit; really, this is a way to block the main thread while QEV is runni...">qev_wait_for_exit()</a> in order for QEV to clean up after itself; typically, the main thread of the application will already be waiting. </p>

</div>
</div>
<a class="anchor" id="a9a1cebfadef1f99799156106551418cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_listen </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>ip_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const guint16&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instruct quick event to listen on a socket for connections and route them into the event handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip_address</td><td>The IP address to listen on </td></tr>
    <tr><td class="paramname">port</td><td>The port to listen on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abe3eecf6974eb7eec71a9905ec1d60ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_listen_ssl </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>ip_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const guint16&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>cert_path0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>key_path0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>cert_path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>key_path1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instruct quick event to listen on an SSL socket for connections and route them into the event handler. </p>
<p>You may pass in both RSA and EC/DSA certificates and keys; each certificate is expected to be a certificate chain that will be given to clients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip_address</td><td>The IP address to listen on </td></tr>
    <tr><td class="paramname">port</td><td>The port to listen on </td></tr>
    <tr><td class="paramname">cert_path0</td><td>The path to the server's CA file </td></tr>
    <tr><td class="paramname">key_path0</td><td>The path to the server's private key file in PEM </td></tr>
    <tr><td class="paramname">cert_path1</td><td>The path to another CA file </td></tr>
    <tr><td class="paramname">key_path1</td><td>The path to another private key file in PEM </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae4c22123de090379112e3b4b2d17cef4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_listen_udp </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>ip_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const guint16&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instruct quick event to listen on on a UDP socket for messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip_address</td><td>The IP address to listen on </td></tr>
    <tr><td class="paramname">port</td><td>The port to listen on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15ef3d34b7758405e346c62204d45c2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_listen_unix </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instruct quick event to create a Unix socket at the given path and listen on it. </p>
<p>This is mainly for getting around the TCP/IP limit of 65K clients and is therefore only used for streaming sockets, not datagram.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path for the socket </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b8f634422145a23236cea847c43e465"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_lock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire a lock on a client. </p>
<p>This function will busy wait, while yielding its run time, until it is able to acquire a lock on a client, so you probably shouldn't use this for things like long-blocking IO operations, or other things that take a while.</p>
<dl class="section note"><dt>Note</dt><dd>This is a reentrant lock.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The client to acquire the lock on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adaefa0e5f5d5cb86abcb733b5e3ecaf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_on_close </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notification that a client has closed / been closed. </p>
<p>At this point, you may write a final farewell message to the client so that it knows why it's being killed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The client that closed. </td></tr>
    <tr><td class="paramname">reason</td><td>The reason the client closed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1984a0000bead164543cc55643c2505"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_on_exit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A notification that QEV is going to shut down. </p>
<p>In this function, it's a good idea to tear down ALL parts of your application that call ANY qev_* functions. When this function is called, all QEV threads have exited, so there will be no future callbacks. </p>

</div>
</div>
<a class="anchor" id="aed3f970d0f8798f00a4af312392982b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_on_open </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notification that a new client was accepted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The client that just opened [<em>transfer-none</em>] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a953d3480791333ad301b54ff1ddc702e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_on_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A notification that the client has data for reading. </p>
<dl class="section note"><dt>Note</dt><dd>The data for the client is in <code>rbuff</code> in the client struct.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Data MAY ONLY be read and removed from the client's rbuff; expanding it will result in incorrect memory pressure calculations.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The client ready for reading [<em>transfer-none</em>] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c703f9b2602437fd10d96d89f1cd719"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_on_tick </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fired after every iteration of the event loop from every QEV thread. </p>
<p>This is mainly used to execute periodic events that don't need to be on a timer. </p>

</div>
</div>
<a class="anchor" id="a713ffbf3ddf74e30fa09592a1cd3a387"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_on_udp </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsize&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>ip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A notification that there is a new UDP message waiting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The data that was received </td></tr>
    <tr><td class="paramname">len</td><td>The length of the data </td></tr>
    <tr><td class="paramname">ip</td><td>Where the dat came from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83cc19854a4663e6918c335f8b74a642"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_setnofile </td>
          <td>(</td>
          <td class="paramtype">const gint&#160;</td>
          <td class="paramname"><em>nofile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the limits for the number of open files for this process. </p>
<p>It is a fatal error if the OS denies the request. </p>

</div>
</div>
<a class="anchor" id="ab6e8185700f3e0fb2663606f986e9c7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GString* qev_surrogate_flush </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *&#160;</td>
          <td class="paramname"><em>surrogate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Steal the entire write buffer from the surrogate client. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surrogate</td><td>The surrogate to flush from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The surrogate's write buffer </dd></dl>

</div>
</div>
<a class="anchor" id="af231495c7ec8db41bc52beb4b72df057"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a>* qev_surrogate_new </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a surrogate client. </p>
<p>A surrogate client is really just a fake client that has no active socket behind it and is useful for multiplexing a bunch of clients onto a single, real client.</p>
<p>A surrogate client is identical to a real client with the following exceptions:</p>
<ul>
<li>The client WILL NEVER fire an on_read event. It is up to the application to route read events from real clients to surrogates.</li>
<li>Writes to the client will just buffer into userspace until flushed to a real client; see <a class="el" href="qev_8h.html#ab6e8185700f3e0fb2663606f986e9c7a" title="Steal the entire write buffer from the surrogate client. ">qev_surrogate_flush()</a>.</li>
<li>The client MUST be closed manually.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>A new surrogate, or NULL if there are too many clients already </dd></dl>

</div>
</div>
<a class="anchor" id="ae15165fdf5186dca35cf6a9fcf0876ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_timeout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qev_8h.html#a6da5ae1902f109059dcbedd768730987">qev_timeout_t</a> **&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a timeout on a client. </p>
<p>Setting a timeout on an already active timeout overwrites the previous one.</p>
<dl class="section note"><dt>Note</dt><dd>If a client is in the process of being closed, no timeout will be set.</dd>
<dd>
You SHOULD call <a class="el" href="qev_8h.html#aac3bbc94c29c04dd0fda08772843f78f" title="Clear a timeout on a client and release your reference to the timeout. ">qev_timeout_clear()</a> in <a class="el" href="qev_8h.html#adaefa0e5f5d5cb86abcb733b5e3ecaf1" title="Notification that a client has closed / been closed. ">qev_on_close()</a> so that the client can be cleaned up as quickly as possible. Otherwise, the timeouts will remain in memory with the reference to the client until they are fired.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The client to set the timeout on </td></tr>
    <tr><td class="paramname">timeout</td><td>The location where the timeout should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac3bbc94c29c04dd0fda08772843f78f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_timeout_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qev_8h.html#a6da5ae1902f109059dcbedd768730987">qev_timeout_t</a> **&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a timeout on a client and release your reference to the timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The location of the timeout to clear </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abcbe1b33b3382bfefe4515c863f6f6c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_timer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="qev_8h.html#a01d7c0d364033b754c3636a8d5604546">qev_cb</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const guint&#160;</td>
          <td class="paramname"><em>seconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const guint&#160;</td>
          <td class="paramname"><em>ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a callback to be fired on a timer. </p>
<dl class="section attention"><dt>Attention</dt><dd>There is no way to disable or remove a timer; these timers are not for one-off events.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Timers will never overlap; if a timer backs up, it will be fired from the same thread right after the previous timer callback returns.</dd>
<dd>
This is the only non-static part of QEV simply because each timer needs a different callback, and making that static is pretty much a pointless mess.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>The function to be called on a timer. </td></tr>
    <tr><td class="paramname">seconds</td><td>The number of seconds between fn calls </td></tr>
    <tr><td class="paramname">ms</td><td>The number of milliseconds (in addition to seconds) between fn calls. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abdcd132e1dfc4f0e49e3f021a04dffe7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_unlock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a lock on a client. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The client to release the lock on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd7977ee0344f557d3c1e6fa8eb41c2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_wait_for_exit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows you to wait for QEV to exit; really, this is a way to block the main thread while QEV is running. </p>
<dl class="section note"><dt>Note</dt><dd>This function will block forever if you call it from a QEV thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a24cec6f518c31ba7fbf802b88082091a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsize&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes data to the client. </p>
<dl class="section attention"><dt>Attention</dt><dd>This function acquires a lock on a client, and as the lock is not reentrant, it must not be held by the caller, or this will block forever.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The client to write to. </td></tr>
    <tr><td class="paramname">buff</td><td>The buffer to send to the client </td></tr>
    <tr><td class="paramname">len</td><td>The amount of data in the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a65edb890b3885a2e11d243308276fb72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qev_writef </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="qev_8h.html#a5b8413775ba81d4752959dfaaa6af560">QEV_CLIENT</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows you to use qev_write in a printf() style. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The client to write to </td></tr>
    <tr><td class="paramname">format</td><td>The string format </td></tr>
    <tr><td class="paramname">...</td><td>The parameters for the format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 14 2014 13:53:13 for QuickIO by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
